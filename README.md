**Overview**

This repository provides an implementation of the analysis described in [LePage’s lectures on Lattice QCD](https://arxiv.org/abs/hep-lat/0506036). The project explores the numerical formulation Quantum Chromodynamics (QCD) on a discretized space-time lattice, focusing on Monte Carlo methods, path integrals, and gauge field computations. 


**Files Description**

We present a brief description of the classes implemented to obtain all the results presented in LePage's work. To run the simulations use the associated main. Please refer to the report (An Introduction to Lattice QCD) for a deeper discussion of each class.

- "NumericalPathIntegral.py": This class is the starting point and provides a numerical framework for evaluating quantum mechanical path integrals. It supports different potential models (harmonic and quartic) and implements the VEGAS algorithm for efficient integration. The class enables computation of propagators, ground state wavefunction, ground state energy (these last two only for the harmonic case), and visualization of results.
- "PathIntegralMonteCarlo.py": This class implements a Monte Carlo algorithm for numerically evaluating first-state excitation energy from the propagator. The code supports both harmonic and anharmonic potentials and employs a Metropolis-based algorithm for sampling path configurations. Various action discretizations, including unimproved, improved, and ghost-free formulations, are implemented to analyze their impact on both the results and statistical errors, which are handled using binning and bootstrap methods.
- "EOMSolver.py": This class implements a numerical solver for the equation of motion (EOM) for the harmonic oscillator in a discretized one-dimensional system. It supports different discretizations of the action (the same ones present in the previously described class). The solver constructs the corresponding coefficient matrices, applies Dirichlet boundary conditions, and numerically extracts the squared frequency of the fundamental mode. Additionally, the ghost mode frequency is computed for the improved action and fitted against theoretical expectations. The implementation is optimized with Numba for efficient matrix construction and solution.
- "WilsonLatticeUtils.py": This class implements the evaluation of the Wilson Loop of dimensions width * height (which can be set directly by the user in the main program) for a lattice of size N. After generating the lattice for the simulation (together with the identity matrices for the links), a set of SU(3) matrices is created. Using a Metropolis-based algorithm, the system is first thermalized and then updated. At this stage, the value of the Wilson Loops for the current lattice configuration, normalized over the lattice volume, is evaluated. This process is repeated N_cf times, and an array of N_cf Wilson Loops is then printed as output.
- "StaticPotetialUtils.py": This subclass extends "WilsonLatticeUtils" Class to compute the static quark potential using Wilson Loops.  It implements the computation of planar Wilson loops for various spatial and temporal separations to extract the static potential using the asymptotic behavior of Wilson loops. It supports link smearing to reduce ultraviolet fluctuations and includes a fitting routine to compare the results with the Cornell potential V(r) = σr - b/r + c. The class enables lattice thermalization, updates configurations using Metropolis algorithms, and calculates the static potential while managing statistical errors. Functions for the gauge covariant derivative and graphical analysis of the extracted potential are also implemented.
